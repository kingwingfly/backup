//! The `Operations` trait

use crate::{
    api::ApiProvider,
    attr::ResAttr,
    config::Config,
    relation::{ResRel, ResSetRel},
    FavCoreResult,
};
use reqwest::{Client, Response};

/// Making a client able to perform operations.
///
/// Work with [`ApiProvider`] and [`Config`] to perform operations.
/// The operations supported should be included in enum `K`.
/// - [`LocalOperations`]'s async methods cannot be Send.
/// - [`Operations`] is generated by [`trait_variant::make`], which implements `Send`.
/// For more information, see [Rust Blog](https://blog.rust-lang.org/2023/12/21/async-fn-rpit-in-traits.html#async-fn-in-public-traits).
/// # Example
/// ```no_run
/// # #[path = "test_utils/mod.rs"]
/// # mod test_utils;
/// use test_utils::data::App;
/// use fav_core::ops::Operations;
/// # #[tokio::main]
/// # async fn main() {
///     let mut app = App::default();
///     app.login().await.unwrap();
/// # }
/// ```
#[allow(missing_docs)]
#[trait_variant::make(Operations: Send)]
pub trait LocalOperations<K>: ApiProvider<K> + Config
where
    K: Send,
{
    async fn login(&mut self) -> FavCoreResult<()>;
    async fn logout(&mut self) -> FavCoreResult<()>;
    /// Fetch one resource
    async fn fetch(&self, resource: &mut impl ResAttr) -> FavCoreResult<()>;
    /// Pull one resource
    async fn pull(&self, resource: &mut impl ResAttr) -> FavCoreResult<()>;

    /// Return a `&'static reqwest::Client`, use it to perform operations during the lifetime of the client.
    /// # Example
    /// ```no_run
    /// use std::sync::OnceLock;
    /// use reqwest::Client;
    /// // In `Operations`'s implementation
    /// fn client() {
    ///     static CLIENT: OnceLock<Client> = OnceLock::new();
    ///     let client = CLIENT.get_or_init(Client::new);
    /// }
    /// ```
    /// In practice, you should make full use of `Config` trait to initialize the client to meet actual needs.
    fn client(&self) -> &'static Client {
        use std::sync::OnceLock;
        let headers = self.headers();
        static CLIENT: OnceLock<Client> = OnceLock::new();
        CLIENT.get_or_init(|| Client::builder().default_headers(headers).build().unwrap())
    }

    /// Request the api, which is returned by `Api::api(api_kind)`,
    /// and with the method, which is returned `Api::method()`.
    /// Use the provided params, and client with default headers `Config::headers()`.
    fn request(
        &self,
        api_kind: K,
        params: impl IntoIterator<Item = &'static str> + Send,
    ) -> impl core::future::Future<Output = FavCoreResult<Response>> {
        async {
            let client = self.client();
            let api = self.api(api_kind);
            let resp = client
                .request(
                    api.method(),
                    api.url(api.params().into_iter().zip(params).collect()),
                )
                .send()
                .await
                .unwrap();
            Ok(resp)
        }
    }
}

/// `LocalOperationsExt`, including methods to batch fetch and pull, however,
/// it is synchronize since methods in [`LocalOperations`] is not `Send`.
pub trait LocalOperationsExt<K>: LocalOperations<K>
where
    K: Send,
{
    /// Fetch resources
    fn fetch_all<R>(
        &self,
        resources: &mut impl ResSetRel<R>,
    ) -> impl core::future::Future<Output = FavCoreResult<()>>
    where
        R: ResRel,
    {
        async {
            for r in resources.iter_mut() {
                self.fetch(r).await?;
            }
            Ok(())
        }
    }

    /// Pull the resources
    fn pull_all<R>(
        &self,
        resources: &mut impl ResSetRel<R>,
    ) -> impl core::future::Future<Output = FavCoreResult<()>>
    where
        R: ResRel,
    {
        async {
            for r in resources.iter_mut() {
                self.pull(r).await?;
            }
            Ok(())
        }
    }
}

impl<T, K> LocalOperationsExt<K> for T
where
    T: LocalOperations<K>,
    K: Send,
{
}

/// `LocalOperationsExt`, including methods to batch fetch and pull, however,
/// it is synchronize since methods in [`LocalOperations`] is not `Send`.
pub trait OperationsExt<K>: Operations<K>
where
    K: Send + 'static,
{
    /// Fetch resources
    fn fetch_all<R>(
        &'static self,
        resources: &'static mut impl ResSetRel<R>,
    ) -> impl core::future::Future<Output = FavCoreResult<()>>
    where
        R: ResRel + 'static,
    {
        async {
            let mut rs = resources.iter_mut();
            loop {
                let batch: Vec<_> = rs.by_ref().take(10).collect();
                if batch.is_empty() {
                    break;
                }
                let jhs: Vec<_> = batch
                    .into_iter()
                    .map(|r| tokio::spawn(self.fetch(r)))
                    .collect();
                for jh in jhs {
                    if let Err(e) = jh.await.unwrap() {
                        println!("{e}");
                    }
                }
            }
            Ok(())
        }
    }

    /// Pull the resources
    fn pull_all<R>(
        &'static self,
        resources: &'static mut impl ResSetRel<R>,
    ) -> impl core::future::Future<Output = FavCoreResult<()>>
    where
        R: ResRel + 'static,
    {
        async {
            let mut rs = resources.iter_mut();
            loop {
                let batch: Vec<_> = rs.by_ref().take(10).collect();
                if batch.is_empty() {
                    break;
                }
                let jhs: Vec<_> = batch
                    .into_iter()
                    .map(|r| tokio::spawn(self.pull(r)))
                    .collect();
                for jh in jhs {
                    if let Err(e) = jh.await.unwrap() {
                        println!("{e}");
                    }
                }
            }
            Ok(())
        }
    }
}

impl<T, K> OperationsExt<K> for T
where
    T: Operations<K>,
    K: Send + 'static,
{
}
